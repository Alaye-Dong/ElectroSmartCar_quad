C251 COMPILER V5.60.0,  pid                                                                17/07/23  20:22:17  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE pid
OBJECT MODULE PLACED IN .\Out_File\pid.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE pid.c XSMALL ROM(HUGE) WARNINGLEVEL(3) BROWSE INCDIR(..\..\Libraries\l
                    -ibraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..\USER\inc;..\USER\src) DEBUG P
                    -RINT(.\Out_File\pid.lst) OBJECT(.\Out_File\pid.obj) 

stmt  level    source

    1          #include "pid.h"
    2          #include "headfile.h"
    3          
    4          float last_err1, last_err2 = 0;
    5          float Target_speed1, Target_speed2;
    6          float cha_err1, cha_err2;
    7          
    8          float g_dirControl_P = 1.925;         //直道控制P 0.8
    9          float g_dirControl_D = 0.285;           //直道控制D     2.4
   10          float Motor_Kp_L = 2.0, Motor_Ki_L = 2.21; //55 5.7
   11          float Motor_Kp_R = 2.79, Motor_Ki_R = 2.10; //37 0.3
   12          float angle_kp1 = 0.425;
   13          
   14          int error2, error_pre2;
   15          int error1,error_pre;
   16          
   17          int normal_speed = 150, round_speed = 150;// 普通速度，环岛速度
   18          
   19          float v_angle;
   20          float angle = 0;//积分角度
   21          float now_x,gr;
   22          
   23          float y_v_angle;
   24          float angle_y = 0;
   25          float now_y,gr_y;
   26          
   27          void dir_pid()      //转向环位置式
   28          {
   29   1      
   30   1                      cha_err2 = g_fDirectionError[0] * 2.1 + (g_fDirectionError[0] - last_err2) * 1; //
   31   1                      last_err2 = g_fDirectionError[0];
   32   1                      if(g_ValueOfAD[2]<=0&&g_ValueOfAD[3]<=0)//停车
   33   1                      {
   34   2                              Target_speed1 = 0;//speed - price_PWM; //1.5
   35   2                              Target_speed2 = 0;//speed + price_PWM; //0.8
   36   2      
   37   2                      }
   38   1                      else
   39   1                      {
   40   2                              angle = 0;
   41   2                              Ordinary_trace();
   42   2                      }  
   43   1      }
   44          
   45          void Target_speed()
   46          {       
   47   1                      Target_speed1 = normal_speed - abs(v_angle)*0.13-abs(y_v_angle)*0.3- cha_err1*0.2;
   48   1                      Target_speed2 = normal_speed - abs(v_angle)*0.13-abs(y_v_angle)*0.3+ cha_err1*0.2;
   49   1                      
   50   1                      BEEP = 0;       
   51   1      }
   52          
   53          void speedL_pid()  //左轮速度内环pid
   54          {  
   55   1                      error2=(int)(Target_speed2-speed2);     
   56   1                      duty2=duty2+(error2-error_pre2)*Motor_Kp_L+error2*Motor_Ki_L;
   57   1                      error_pre2=error2;       
C251 COMPILER V5.60.0,  pid                                                                17/07/23  20:22:17  PAGE 2   

   58   1                      if(duty2>=8000) duty2=8000;//限幅
   59   1                      else if(duty2<=-3500) duty2=-3500;
   60   1      }
   61          
   62          void speedR_pid()  //右轮速度内环pid
   63          { 
   64   1                      error1=(int)(Target_speed1-speed1);
   65   1                      duty1=duty1+(error1-error_pre)*Motor_Kp_R+error1*Motor_Ki_R;
   66   1                      error_pre=error1;        
   67   1                      if(duty1>=7000) duty1=7000;//限幅
   68   1                      else if(duty1<=-3500) duty1=-3500;
   69   1      }
   70          
   71          void mpu660_PID() //角速度，角度计算
   72          {
   73   1                      float v_angle_array[5],temp;
   74   1                      int i,j;
   75   1          imu660ra_get_gyro();
   76   1                      
   77   1                      for(i = 0; i < 5 - 1; i++)
   78   1                      {
   79   2                                      v_angle_array[i] = imu660ra_gyro_transition(imu660ra_gyro_z);
   80   2                      }
   81   1                      
   82   1                      for(i = 0; i < 5 - 1; i++)
   83   1                      {
   84   2                              for(j = 0; j < 5 - 1 - i; j++)
   85   2                              {
   86   3                                      if(v_angle_array[j] > v_angle_array[j + 1])
   87   3                                              {
   88   4                                                      temp = v_angle_array[j];
   89   4                                                      v_angle_array[j] = v_angle_array[j + 1];
   90   4                                                      v_angle_array[j + 1] = temp;
   91   4                                              }
   92   3                              }               
   93   2                      }
   94   1                      
   95   1                      v_angle=(float)(v_angle_array[1]+v_angle_array[2]+v_angle_array[3])/3;
   96   1                              
   97   1                      
   98   1                      if(abs(g_ValueOfAD[2]-g_ValueOfAD[2])<=15&&g_ValueOfAD[2]>=45&&g_ValueOfAD[2]>=45)
   99   1                      {
  100   2                              angle_kp1 = 0.12;
  101   2                      }
  102   1                      else
  103   1                      {
  104   2                              angle_kp1 = 0.03;
  105   2                      }
  106   1      
  107   1      }
  108          
  109          void IMU660ra_Angle_Y_V_Filter()        //Y轴角速度角度获取滤波
  110          {
  111   1                      float y_v_angle_array[5],temp;
  112   1                      int i,j;
  113   1          imu660ra_get_gyro();
  114   1                      
  115   1                      for(i = 0; i < 5 - 1; i++)
  116   1                      {
  117   2                                      y_v_angle_array[i] = imu660ra_gyro_transition(imu660ra_gyro_y);
  118   2                      }
  119   1                      
  120   1                      for(i = 0; i < 5 - 1; i++)
  121   1                      {
  122   2                              for(j = 0; j < 5 - 1 - i; j++)
  123   2                              {
C251 COMPILER V5.60.0,  pid                                                                17/07/23  20:22:17  PAGE 3   

  124   3                                      if(y_v_angle_array[j] > y_v_angle_array[j + 1])
  125   3                                              {
  126   4                                                      temp = y_v_angle_array[j];
  127   4                                                      y_v_angle_array[j] = y_v_angle_array[j + 1];
  128   4                                                      y_v_angle_array[j + 1] = temp;
  129   4                                              }
  130   3                              }               
  131   2                      }
  132   1                      
  133   1                      y_v_angle=(float)(y_v_angle_array[1]+y_v_angle_array[2]+y_v_angle_array[3])/3;
  134   1      }
  135          
  136          void mpu660_angle() 
  137          {
  138   1          mpu660_PID();
  139   1          gr = v_angle;
  140   1          now_x = gr; //根据设置换算
  141   1          angle += (now_x) * 0.005; //积分：角速度*积分时间10ms
  142   1      }
  143          
  144          void IMU660ra_Angle_Y()
  145          {
  146   1                      IMU660ra_Angle_Y_V_Filter();
  147   1          gr_y = y_v_angle;
  148   1          now_y = gr_y; //根据设置换算
  149   1          angle_y += (now_y) * 0.005; //积分：角速度*积分时间10ms
  150   1      }
  151          
  152          void Ordinary_trace()  //普通循迹
  153          { 
  154   1                      mpu660_PID();
  155   1                      IMU660ra_Angle_Y_V_Filter();
  156   1      
  157   1                      if(g_ValueOfAD[2]<=15&&(g_ValueOfAD[2]<g_ValueOfAD[3]))
  158   1                      {
  159   2                              //BEEP = 1;
  160   2                              cha_err1 = -73;
  161   2                              Target_speed();
  162   2                      }
  163   1                      else if(g_ValueOfAD[3]<=15&&g_ValueOfAD[2]!=0&&(g_ValueOfAD[3]<g_ValueOfAD[2]))
  164   1                      {   
  165   2                                      //BEEP = 1;
  166   2                                      cha_err1 = 74;
  167   2                                      Target_speed();
  168   2                      }
  169   1                      else
  170   1                      {
  171   2                                      BEEP = 0;
  172   2                                      cha_err1 = (g_fDirectionError[2] * g_dirControl_P + (g_fDirectionError[2] - last_err1) * g_dirControl
             -_D)+v_angle*angle_kp1;
  173   2                                      last_err1 = g_fDirectionError[2];
  174   2                                      Target_speed();
  175   2                      }
  176   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =    ------     ------
  ecode size           =      1181     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        96         40
  bit size             =    ------     ------
C251 COMPILER V5.60.0,  pid                                                                17/07/23  20:22:17  PAGE 4   

  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        92     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
