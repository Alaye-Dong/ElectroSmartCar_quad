C251 COMPILER V5.60.0,  pid                                                                25/06/23  16:42:07  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE pid
OBJECT MODULE PLACED IN .\Out_File\pid.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE pid.c LARGE INTR2 ROM(HUGE) WARNINGLEVEL(3) BROWSE INCDIR(..\..\Librar
                    -ies\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..\USER\inc;..\USER\src) DE
                    -BUG PRINT(.\Out_File\pid.lst) TABS(2) OBJECT(.\Out_File\pid.obj) 

stmt  level    source

    1          #include "pid.h"
    2          #include "headfile.h"
    3          
    4          int last_err1, last_err2 = 0;
    5          int speed;
    6          float Target_speed1, Target_speed2;
    7          float cha_err1, cha_err2;
    8          float g_dirControl_P = 1.925;         //直道控制P 0.8
    9          float g_dirControl_D = 0.245;         //直道控制D 2.4
   10          float Motor_Kp_L = 2.0, Motor_Ki_L = 2.21; //55 5.7
   11          float Motor_Kp_R = 2.79, Motor_Ki_R = 2.10; //37 0.3
   12          float angle_kp1 = 0.425;
   13          float price_PWM;
   14          float v_angle;
   15          int error2, error_pre2;
   16          int error1,error_pre;
   17          float ZX_kp = 0.10; //0.1
   18          float ZX_kd = 0.00;
   19          void dir_pid()      //转向环位置式
   20          {
   21   1      
   22   1          cha_err2 = g_fDirectionError[0] * 2.1 + (g_fDirectionError[0] - last_err2) * 1; //
   23   1          last_err2 = g_fDirectionError[0];
   24   1        if(g_ValueOfAD[2]<=0&&g_ValueOfAD[3]<=0)
   25   1        {
   26   2          Target_speed1 = 0;//speed - price_PWM; //1.5
   27   2          Target_speed2 = 0;//speed + price_PWM; //0.8
   28   2      
   29   2        
   30   2        }
   31   1        else
   32   1        {
   33   2        if(g_ValueOfAD[5]>75&&g_ValueOfAD[0]>75)
   34   2        {
   35   3        cha_err1 = cha_err2;
   36   3        Target_speed1 = 130 - cha_err1*0.01;
   37   3          Target_speed2 = 130 + cha_err1*0.01;
   38   3        
   39   3        }
   40   2      else
   41   2      {
   42   3       if(g_ValueOfAD[2]<=25&&(g_ValueOfAD[2]<g_ValueOfAD[3]))
   43   3      {
   44   4        cha_err1 = -71;
   45   4       Target_speed1 = 115 - cha_err1*0.15;
   46   4          Target_speed2 = 115 + cha_err1*0.15;
   47   4      }
   48   3      else if(g_ValueOfAD[3]<=25&&g_ValueOfAD[2]!=0&&(g_ValueOfAD[3]<g_ValueOfAD[1]))
   49   3      {
   50   4        cha_err1 = 73;
   51   4       Target_speed1 = 115 - cha_err1*0.15;
   52   4          Target_speed2 = 115 + cha_err1*0.15;
   53   4      }
   54   3      else
   55   3      {
   56   4        if(zhidaoflag>=90)
   57   4        {
C251 COMPILER V5.60.0,  pid                                                                25/06/23  16:42:07  PAGE 2   

   58   5          Target_speed1 = 140 - cha_err1*0.15;
   59   5          Target_speed2 = 140 + cha_err1*0.15;
   60   5          cha_err1 = (0.20*g_fDirectionError[2] * g_dirControl_P + (g_fDirectionError[2] - last_err1) * g_dirCont
             -rol_D*1.25);
   61   5          last_err1 = g_fDirectionError[2]; 
   62   5        }
   63   4        else
   64   4        {
   65   5        cha_err1 = (g_fDirectionError[2] * g_dirControl_P + (g_fDirectionError[2] - last_err1) * g_dirControl_D)
             -;
   66   5        last_err1 = g_fDirectionError[2];
   67   5        Target_speed1 = 115 - cha_err1*0.15;
   68   5          Target_speed2 = 115 + cha_err1*0.15;
   69   5        }
   70   4      }
   71   3       }  
   72   2      }
   73   1      
   74   1      
   75   1        }
   76          void Target_speed()
   77          {
   78   1          
   79   1          
   80   1        
   81   1      }
   82          
   83          
   84          
   85          
   86          
   87          void speedL_pid()  //左轮速度内环pid
   88          {  
   89   1        
   90   1         error2=(int)(Target_speed2-speed2);  
   91   1         duty2=duty2+(error2-error_pre2)*Motor_Kp_L+error2*Motor_Ki_L;
   92   1         error_pre2=error2;  
   93   1        if(duty2>=8000) duty2=8000;//限幅
   94   1        else if(duty2<=-3500) duty2=-3500;
   95   1        
   96   1      }
   97          
   98          void speedR_pid()  //右轮速度内环pid
   99          { 
  100   1         
  101   1         error1=(int)(Target_speed1-speed1);
  102   1         duty1=duty1+(error1-error_pre)*Motor_Kp_R+error1*Motor_Ki_R;
  103   1         error_pre=error1;   
  104   1        if(duty1>=7000) duty1=7000;//限幅
  105   1        else if(duty1<=-3500) duty1=-3500;
  106   1        
  107   1        
  108   1      }
  109          
  110          void mpu660_PID()
  111          {
  112   1           imu660ra_get_gyro();
  113   1          v_angle = imu660ra_gyro_transition(imu660ra_gyro_z);
  114   1      
  115   1      }
  116          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =    ------     ------
  ecode size           =      1073     ------
C251 COMPILER V5.60.0,  pid                                                                25/06/23  16:42:07  PAGE 3   

  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        74     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        88     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
