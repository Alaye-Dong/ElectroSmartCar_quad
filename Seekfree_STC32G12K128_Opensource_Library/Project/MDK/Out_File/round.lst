C251 COMPILER V5.60.0,  round                                                              27/06/23  14:18:26  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE round
OBJECT MODULE PLACED IN .\Out_File\round.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE round.c LARGE INTR2 ROM(HUGE) WARNINGLEVEL(3) BROWSE INCDIR(..\..\Libr
                    -aries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..\USER\inc;..\USER\src) 
                    -DEBUG PRINT(.\Out_File\round.lst) TABS(2) OBJECT(.\Out_File\round.obj) 

stmt  level    source

    1          #include "headfile.h"
    2          #include "round.h"
    3          
    4          int e_r1, e_r2;
    5          int cd_time_1 = 0;
    6          int flag_r_hd = 0; //入环岛预测
    7          int flag_c_hd = 0; //出环岛标志位
    8          int flag_hding1 = 0; //环岛内循迹标志位
    9          int flag_hding2 = 0; //出环岛辅助标志位
   10          int flag_hd_Z = 0; //左环岛
   11          int flag_hd_R = 0; //右环岛
   12          int roundcount = 0;
   13          int roundcount2 = 0;
   14          int CK_count=0;
   15          int CK_count2=0;
   16          int e_r2;
   17          int XJ=0;
   18          int HD = 0;
   19          int flag_hd_Z_2;
   20          int count_OUT = 800;
   21          int count_IN = 400;
   22          int count_R = 150;
   23          void knn(void)
   24          {
   25   1      
   26   1          float mask[2][5] = {100, 100, 100, 70,
   27   1                                100    
   28   1                              , 100, 6, 6, 100, 91
   29   1                             };//三叉
   30   1          e_r1 = pow(mask[0][0] - g_ValueOfAD[2], 2) + pow(mask[0][1] - g_ValueOfAD[3], 2) + pow(mask[0][2] - g
             -_ValueOfAD[1], 2) + pow(mask[0][3] - g_ValueOfAD[4], 2);
   31   1          e_r2 = pow(100 - g_ValueOfAD[2], 2) + pow(100 - g_ValueOfAD[3], 2) + pow(100 - g_ValueOfAD[1], 2) + pow
             -(100 - g_ValueOfAD[4], 2)+pow(8 - g_ValueOfAD[5], 2)+pow(8 - g_ValueOfAD[0], 2);
   32   1          
   33   1         if(e_r1<=450&&flag_r_hd==0&&g_ValueOfAD[2]>=75&&g_ValueOfAD[3]>=75&&g_ValueOfAD[1]>=80&&flag_hd_R==0)
   34   1         {
   35   2           flag_hd_R = 1;
   36   2           flag_r_hd = 1;
   37   2           
   38   2         }
   39   1        if(e_r2<1000&&g_ValueOfAD[2]>=75&&g_ValueOfAD[3]>=75&&flag_hd_Z==0&&flag_hd_R==2) 
   40   1        {
   41   2           flag_hd_Z = 1;
   42   2        
   43   2        }   
   44   1                       
   45   1                             
   46   1        //  e_r2 = pow(mask[1][0] - all, 2) + pow(mask[1][1] - al, 2) + pow(mask[1][2] - mid, 2) + pow(mask[1][
             -3] - ar, 2) + pow(mask[1][4] - arr, 2);
   47   1      }
   48          
   49          void RuKu()
   50          {
   51   1      
   52   1           roundcount =(ctimer_count_read(CTIM0_P34)+ctimer_count_read(CTIM3_P04))*0.1;
   53   1           roundcount2 = roundcount2 + roundcount;
   54   1        if(roundcount2>=0&&roundcount2<=1000)
C251 COMPILER V5.60.0,  round                                                              27/06/23  14:18:26  PAGE 2   

   55   1        {
   56   2        
   57   2        
   58   2         Target_speed1 = 120;
   59   2         Target_speed2 = 120;
   60   2        cha_err1 = 0;
   61   2        }
   62   1        else if(roundcount2<3800&&roundcount2>800)
   63   1        {
   64   2        
   65   2        Target_speed1 = -120;
   66   2         Target_speed2 = -120;
   67   2        
   68   2        cha_err1 = 70;
   69   2          
   70   2          }
   71   1        else if(roundcount2>=3800)
   72   1        {
   73   2        
   74   2        Target_speed1 = 0;
   75   2         Target_speed2 = 0;
   76   2        
   77   2        cha_err1 = 0;
   78   2          
   79   2          }
   80   1        
   81   1      
   82   1      
   83   1      }
   84          void Huan_Dao_Z()
   85          {
   86   1      
   87   1         Target_speed1 = 110;
   88   1         Target_speed2 = 110;
   89   1        if(flag_hd_Z==1)
   90   1        {
   91   2            roundcount =(ctimer_count_read(CTIM0_P34)+ctimer_count_read(CTIM3_P04))*0.1;
   92   2           roundcount2 = roundcount2 + roundcount;
   93   2          if(roundcount2<=200&&roundcount2>=0)
   94   2          {
   95   3             cha_err1 = 0.2*g_fDirectionError[2] * g_dirControl_P + (g_fDirectionError[2] - last_err1) * g_dirCon
             -trol_D*0.4;
   96   3              last_err1 = g_fDirectionError[2];
   97   3          
   98   3          }
   99   2          else if(roundcount2>200&&roundcount2<=2500)
  100   2          {
  101   3           cha_err1 = -55;
  102   3          
  103   3          }
  104   2          else if(roundcount2>2500&&roundcount2<=6000)
  105   2           
  106   2         {
  107   3         
  108   3          cha_err1 = 2.5*g_fDirectionError[2] * g_dirControl_P + (g_fDirectionError[2] - last_err1) * g_dirContr
             -ol_D*1;
  109   3              last_err1 = g_fDirectionError[2];
  110   3         
  111   3         }
  112   2          else if(roundcount2>6000)
  113   2         {
  114   3         flag_hd_Z = 2;
  115   3         flag_r_hd = 0;
  116   3         roundcount2 = 0;
  117   3      
  118   3         }
C251 COMPILER V5.60.0,  round                                                              27/06/23  14:18:26  PAGE 3   

  119   2         }
  120   1      
  121   1         
  122   1      
  123   1      
  124   1      }
  125          void Huan_Dao_R()
  126          {
  127   1         Target_speed1 = 110 - cha_err1*0.15;
  128   1         Target_speed2 = 110 + cha_err1*0.15;
  129   1         
  130   1         if(flag_hd_R==1)
  131   1         {
  132   2           
  133   2        roundcount =(ctimer_count_read(CTIM0_P34)+ctimer_count_read(CTIM3_P04))*0.1;
  134   2           roundcount2 = roundcount2 + roundcount;
  135   2          if(roundcount2<=1000&&roundcount2>=0)
  136   2          {
  137   3           cha_err1 = 0.2*g_fDirectionError[2] * g_dirControl_P + (g_fDirectionError[2] - last_err1) * g_dirContr
             -ol_D*0.4;
  138   3              last_err1 = g_fDirectionError[2];
  139   3          
  140   3          }
  141   2          else if(roundcount2>1000&&roundcount2<=2500)
  142   2          {
  143   3           cha_err1 = +53;
  144   3          
  145   3              }
  146   2          else if(roundcount2>2500&&roundcount2<=7000)
  147   2          {
  148   3           cha_err1 = 2.3*g_fDirectionError[2] * g_dirControl_P + (g_fDirectionError[2] - last_err1) * g_dirContr
             -ol_D*1;
  149   3              last_err1 = g_fDirectionError[2];
  150   3          
  151   3          }
  152   2         
  153   2         else if(roundcount2>7000)
  154   2         {
  155   3         flag_hd_R = 2;
  156   3         flag_r_hd = 0;
  157   3         roundcount2 = 0;
  158   3         }
  159   2         }
  160   1        
  161   1       }
  162          
  163           void obstacle()
  164          {
  165   1        roundcount =(ctimer_count_read(CTIM0_P34)+ctimer_count_read(CTIM3_P04))*0.1;
  166   1        roundcount2 = roundcount2 + roundcount;
  167   1        
  168   1        if(roundcount2>=0&&roundcount2<=1000)
  169   1        {
  170   2          
  171   2          Target_speed1 =-30;
  172   2         Target_speed2 = -30;
  173   2      }
  174   1        else if(roundcount2>1000&&roundcount2<=2500)
  175   1          
  176   1        {
  177   2         Target_speed1 =50;
  178   2         Target_speed2 =50;
  179   2         cha_err1 = 56;
  180   2        }
  181   1        else if(roundcount2<6000&&roundcount2>2500)
  182   1          
C251 COMPILER V5.60.0,  round                                                              27/06/23  14:18:26  PAGE 4   

  183   1        {
  184   2         Target_speed1 =50;
  185   2         Target_speed2 =50;
  186   2        cha_err1 = -60;
  187   2          
  188   2        }
  189   1        else
  190   1        {
  191   2        HD = 0;
  192   2          roundcount2=0;
  193   2        }
  194   1      
  195   1      }
  196          void CHUKU()
  197          { 
  198   1        if(CK_count2>=0&&CK_count2<=1000)
  199   1        {
  200   2          cha_err1 = +60;
  201   2         Target_speed1 =100;
  202   2         Target_speed2 =100;
  203   2        }
  204   1        else
  205   1      {
  206   2          XJ=1;
  207   2      
  208   2      
  209   2      }
  210   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =    ------     ------
  ecode size           =      1872     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        38         40
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       152     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
